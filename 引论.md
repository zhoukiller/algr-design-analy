# 第一章 引论

## 1.1 数学知识

### 1.2.1 指数

$$ X^AX^B=X^{A+B} $$

$$ \frac{X^A}{X^B}=X^{A-B} $$

$$ (X^A)^B=X^{AB} $$

$$ X^N+X^N=2X^N\neq{X^{2N}} $$

$$ 2^N+2^N=2^{N+1} $$

### 1.2.2 对数

> 在计算机科学中，除非有特别声明，否则对数均以2为底

**定义 1.1**

$$X^A=B 当且仅当 \log_x B=A$$

**定理 1.1**

$$\log_A B = \frac{{\log}_C B}{{\log}_C A},A,B,C>0,A\neq1,B\neq1$$

**定理 1.2**

$$\log{AB}=\log{A}+\log{B};A,B>0$$

$$\log{A/B}=\log{A}-\log{B}$$

$$\log{A^B}=B\log{A}$$

$$\log{X}<X，对所有X>0成立$$

### 1.2.3 级数

$$\sum_{i=0}^N 2^i=2^{N+1}-1$$
和
$$\sum_{i=0}^N A^i=\frac{A^{N+1}-1}{A-1}$$
在第二个公式中，如果$0<A<1$，则
$$\sum_{i=0}^N A^i\leq\frac{1}{1-A}$$

$$\sum_{i=1}^N i^2=\frac{N(N+1)(2N+1)}{6}\approx\frac{N^3}{3}$$
$$\sum_{i=1}^N i^k\approx\frac{N^{k+1}}{\lvert{k+1}\rvert}, k\neq-1$$

下列公式中，数$H_N$叫做调和数，其和叫做调和和。其近似值称为**欧拉常数**
$$H_N=\sum_{i=1}^N \frac{1}{i}\approx{log_e N}$$

### 1.2.4 模数运算
如果N整除A-B,那么就说A与B摸N同余，记为$A\equiv B \pmod N$，这意味A除以N与B除以N的余数是一样的。
> 尽量少使用模运算

### 1.2.5 证明的方法

> 证明数据结构分析中的结论最常用的两种方法是归纳法和反证法。

**归纳法证明**

归纳法证明分为两个步骤。

> 第一步是证明**基准情形**，就是证明对于某些小的值的正确性。接着进行**归纳假设**，即假设知道对于某个有限数**k**的所有情况都是成立的，然后使用这个假设证明对于**k+1**也是成立的，即证明该定理。

例如证明斐波那契数列数，$F_k<{\frac{5}{3}^k}$
同理，我们也可以证明
$\sum_{i=1}^N i^2=\frac{N(N+1)(2N+1)}{6}$

**反例法证明**

公式$F_k\leq k^2$不成立，举例$F_11==144>11^2$

**反证法证明**

> 通过假设定理不成立，然后证明该假设导致某个已知性质不成立，从而原假设是错误的。

例如证明素数是无穷的。
假设定理不成立，存在某个最大素数$P_k$。令$P_1,P_2,\cdots,P_k$是依序排列的所有素数
N=$P_1P_2\cdots P_k+1$
，显然$N>P_k$,所以根据假设N不是素数，然而$P_1,P_2,\cdots,P_k$不能整除N，所以假设不成立，所以定理锝证。

## 1.3 递归简论

> 当一个函数用它自己来定义时就称为**递归**的

递归必须要有基准情况，即函数的值不用借助递归即可求得。

> 对于递归是否循环推理的？答案是：虽然用一个方法来定义自身，但是并没有用方法来定义该方法的一个特例。即使用f(5)来得到f(5)的值(直接或间接)才是循环的。

```
public static int bad( int n )
{
      if(n==0)
          return 0;
      else
          return bad(n / 3 + 1) + n - 1;
}
```
**无效终止递归方法**

**递归基本法则**

> 1. **基准情形**。必须要有某种基准的情形，不需要递归就能求解。
> 2. **不断推进**。对于某些递归求解情形，递归调用必须朝着基准情形推进。
> 3. **设计法则**。假设所有递归调用都能运行。
> 4. **合成效益法则**。在求解一个问题的同一实例时，切勿在不同的递归调用里做重复性的工作。

**打印输出整数**

假设仅有一个打印单个数字的I/O方法，命名为printDigit。

```
public static void printOut(int n){
  if(n >= 10)
    printOut(n/10);
  printDigit(n%10);
}
```
为了避免使用mod方法(因为耗时)，所以改为

```
public static void printOut(int n){
  if(n >= 10)
    printOut(n/10);
  printDigit(n-n/10*10);
}
```

## 1.4 实现泛型特性构建 pre-Java 5

### 1.4.1 使用Object表示泛型
2
