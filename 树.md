# 第四章 树

## 4.1 预备知识

**树的定义**
一颗**树**可以是**空集**，也可以是**非空集**；如果是非空集，则树由**根节点**以及0或多个非空的**子树**组成，每颗子树和根通过**边**连接。



**定理**
> 一颗树由N个节点和N-1条边组成。

<br>

**节点关系的定义**
<br>

每个子树的根称为**儿子**，而根称为子树的**父亲**。

没有儿子的节点称为**树叶**，具有相同父亲的节点称为**兄弟**，类似可以定义**祖父**和**孙子**。

如果存在从$n_1$到$n_2$的一条路径，那么$n_1$是$n_2$的**祖先**，而$n_2$是$n_1$的**后裔**；如果$n_1\neq n_2$，则$n_1$是$n_2$的**真祖先**，而$n_2$是$n_1$的**真后裔**。
<br>

**路径**

从节点$n_1$到$n_k$的**路径**定义为节点$n_1,n_2,\cdots,n_k$的**一个序列**。
<br>

**路径的长**
<br>
路径的长定义为该路径上的**边的条数**，即k-1。

>每个节点都有一条长为0的路径到自己。

<br>

**深度**

对于任意节点$n_i$，$n_i$的**深度**为从**根**到$n_i$的**唯一路径的长**。
<br>

**高**

$n_i$的**高**，是$n_i$到一片**树叶**的**最长路径的长**。所有树叶的高度为0。
<br>

>一棵树的高等于根的高。

### 4.1.1 树的实现

树的节点定义：
一个元素指向当前节点，一个元素指向**第一个儿子**节点，一个元素指向**第一个儿子**的下一个**兄弟**节点。

```
class TreeNode
{
  Object element;
  TreeNode firstChild;
  TreeNode nextSibling;
}
```

### 4.1.2 树的遍历及应用

文件系统的目录结构。

**先序遍历**：对节点的操作是在其儿子节点被处理之前进行的。(目录结构的打印)
运行时间为O(N)。
**后序遍历**：对节点的操作是在其儿子节点被处理之后进行的。(文件目录大小的计算)

## 4.2 二叉树

**二叉树**是一颗儿子节点不能多于两个的树。

普通二叉树的**平均深度**为$O(\sqrt N)$。
对于**二叉查找树**的深度平均值为$O(log N)$。
最坏情形下，二叉树的深度为O(N)，即N-1。

### 4.2.1 实现

二叉树节点定义：
```
class BinaryNode
{
  Object element;
  BinaryNode left;
  BinaryNode right;
}
```

**二叉树的性质**
>性质1：二叉树第i层上的结点数目最多为 2{i-1} (i≥1)。
>性质2：深度为k的二叉树至多有2{k}-1个结点(k≥1)。
>性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。
>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。
>性质5：具有N个节点的二叉树具有N+1个null链

### 4.2.2 例子：表达式树

表达式树的**树叶**是**操作数**，其他节点为**操作符**。
一个节点可能有多于两个的儿子，或夜歌节点也可能只有一个儿子，比如**一目运算符**。

我们可以递归打印左子树，然后打印根节点的运算符，然后递归打印右子树。
这种遍历称为**中序遍历**。

**构造表达式树**

算法描述：
1. 读入符号
2. 如果符号是操作数，就建立一个**单节点**的树，入栈。
3. 如果是操作符，则从栈中弹出两颗树$T_1$和$T_2$，然后形成一颗新树，根节点为操作符，左右儿子为$T_1$和$T_2$。然后将新树入栈。
4. 重复1
5. 最后读取符号完成，栈中只有一颗树，即是所求得表达式树。

## 4.3 查找树ADT——二叉查找树

首先，假设**所有项**都是**不同**的。
一颗树的**左子树的所有节点**都**比根节点小**，**右子树的所有节点**都**比根节点大**。

**深度**
平均深度是O(log N)。

### 4.3.1 contains方法
使用递归调用来查找，因为平均栈深度为O(log N)。
**首先**得对节点进行**空树测试**，否则会产生一个NullPointerException异常。应该将**最不可能的情况**(概率最小的情况，即相等)安排到**最后测试**。
这里的递归表达式都是**尾递归**，可以用while循环代替。

也可以使用**函数对象**来实现比较。

### 4.3.2 findMin方法和findMax方法

两个private分别返回树中最小元和最大元的**节点引用**。
这里findMin采用递归实现，而findMax采用循环实现。

首先得处理**空树**的退化情况。

### 4.3.3 insert方法

类似于contains方法，对于**重复元**的处理方法有两种：
1. 不添加
2. 添加一个附加域来存储重复元的频率。

### 4.3.4 remove方法

最困难的操作是remove方法。
情况主要分为3种：
1. 删除的是**叶子节点**，这种情况可以直接删除。
2. 删除的节点只有一个子树，这种情况可以用子树的根直接替代当前节点。
3. 删除的节点有两个子树：
对于这种情况有多种策略可以采用：
1). 通过中序遍历的前继或者后继来替代当前元素，这种策略中采用**后继元**会比较好处理，即通过将右子树的最小节点替代当前删除节点，因为**右子树的最小节点不可能有左子树**，所以操作上会方便些。
2). 如果删除的次数不多，则使用**懒惰删除**，如果树中删除的节点和实际节点数一样，树的**深度**只会比真实删除的情况多一个**常数**。

### 4.3.5 平均情况分析

当我们每降低一层，我们操作树的大小就近似减少一半。所有的操作时间为O(d)，其中d为**访问节点的深度**。

**内部路径长**
一个树所有节点的深度的和称为**内部路径长**。

现证明假设所有插入序列都是等可能的，则树所有节点的平均深度为O(log N)。

证明：
> 令D(N)为具有N个节点的树T的内部路径长，D(1)=0。
>一棵N节点的树由一棵i节点的左子树和一棵(N - i - 1)节点的右子树组成，其中0<=i<N。
> D(i)是左子树的内部路径长。
> 原树种所有节点深度都加1,所以得到递推关系
> D(N)=D(i)+D(N - i - 1) + N - 1。
> 如果所有子树的大小都是等可能出现，对于**二叉查找树**是成立的，但对于**二叉树**不成立。(因为二叉查找树中子树的大小只依赖于第一个插到树种的元素想对的**秩**)。
> 那么D(i)和D(N - i - 1)平均值均为$\frac{1}{N} \sum_{j=0}^{N-1} D(j)$。
> 所以
> $D(N)=\frac{2}{N} \sum_{j=0}^{N-1} D(j) + N - 1$
> 最终求解得**D(N)=O(NlogN)**。所以**任意节点的平均深度为O(log N)**。

对于所有操作的平均运行时间为O(log N)，即d=log N。但是**删除操作**是否会导致所有二叉查找树是否**等可能出现**，所以**不能判断二叉查找树的所有操作是O(log N)**，但是对于**无删除操作或使用懒惰删除的二叉查找树，所有的操作是O(log N)**。

有人已经证明，如果**交替插入删除**$\Theta(N^2)$次，则树的平均深度为$\Theta(\sqrt N)$。

为了平衡插入删除操作后的树的深度，可以使用如下策略：
1. **随机选取**删除元素的**右子树**的最小和最大元来替代当前元素。
2. 使用**平衡结构**，让树的深度不能过深。
3. 使用称为**自调整类结构**。

在二叉查找树情况下，不保证**单个操作**时间为O(log N)界，但是对于**连续M次操作**在最坏情形下花费时间为O(MlogN)。
能达到这种效果的树称为**伸展树**。

## 4.4 AVL 树
