---
output:
  pdf_document:
  latex_engine: pdflatex
  citation_package: natbib
papersize: A4
---

# 第四章 树

## 4.1 预备知识

**树的定义**
一颗**树**可以是**空集**，也可以是**非空集**；如果是非空集，则树由**根节点**以及0或多个非空的**子树**组成，每颗子树和根通过**边**连接。



**定理**
> 一颗树由N个节点和N-1条边组成。

<br>

**节点关系的定义**
<br>

每个子树的根称为**儿子**，而根称为子树的**父亲**。

没有儿子的节点称为**树叶**，具有相同父亲的节点称为**兄弟**，类似可以定义**祖父**和**孙子**。

如果存在从$n_1$到$n_2$的一条路径，那么$n_1$是$n_2$的**祖先**，而$n_2$是$n_1$的**后裔**；如果$n_1\neq n_2$，则$n_1$是$n_2$的**真祖先**，而$n_2$是$n_1$的**真后裔**。
<br>

**路径**

从节点$n_1$到$n_k$的**路径**定义为节点$n_1,n_2,\cdots,n_k$的**一个序列**。
<br>

**路径的长**
<br>
路径的长定义为该路径上的**边的条数**，即k-1。

>每个节点都有一条长为0的路径到自己。

<br>

**深度**

对于任意节点$n_i$，$n_i$的**深度**为从**根**到$n_i$的**唯一路径的长**。
<br>

**高**

$n_i$的**高**，是$n_i$到一片**树叶**的**最长路径的长**。所有树叶的高度为0。
<br>

>一棵树的高等于根的高。

### 4.1.1 树的实现

树的节点定义：
一个元素指向当前节点，一个元素指向**第一个儿子**节点，一个元素指向**第一个儿子**的下一个**兄弟**节点。

```
class TreeNode
{
  Object element;
  TreeNode firstChild;
  TreeNode nextSibling;
}
```

### 4.1.2 树的遍历及应用

文件系统的目录结构。

**先序遍历**：对节点的操作是在其儿子节点被处理之前进行的。(目录结构的打印)
运行时间为O(N)。
**后序遍历**：对节点的操作是在其儿子节点被处理之后进行的。(文件目录大小的计算)

## 4.2 二叉树

**二叉树**是一颗儿子节点不能多于两个的树。

普通二叉树的**平均深度**为$O(\sqrt N)$。
对于**二叉查找树**的深度平均值为$O(log N)$。
最坏情形下，二叉树的深度为O(N)，即N-1。

### 4.2.1 实现

二叉树节点定义：
```
class BinaryNode
{
  Object element;
  BinaryNode left;
  BinaryNode right;
}
```

**二叉树的性质**
>性质1：二叉树第i层上的结点数目最多为$2^{k-1}$ (i≥1)。
>性质2：深度为k的二叉树至多有$2^{k}-1$个结点(k≥1)。
>性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。
>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。
>性质5：具有N个节点的二叉树具有N+1个null链

### 4.2.2 例子：表达式树

表达式树的**树叶**是**操作数**，其他节点为**操作符**。
一个节点可能有多于两个的儿子，或夜歌节点也可能只有一个儿子，比如**一目运算符**。

我们可以递归打印左子树，然后打印根节点的运算符，然后递归打印右子树。
这种遍历称为**中序遍历**。

**构造表达式树**

算法描述：
1. 读入符号
2. 如果符号是操作数，就建立一个**单节点**的树，入栈。
3. 如果是操作符，则从栈中弹出两颗树$T_1$和$T_2$，然后形成一颗新树，根节点为操作符，左右儿子为$T_1$和$T_2$。然后将新树入栈。
4. 重复1
5. 最后读取符号完成，栈中只有一颗树，即是所求得表达式树。

## 4.3 查找树ADT——二叉查找树

首先，假设**所有项**都是**不同**的。
一颗树的**左子树的所有节点**都**比根节点小**，**右子树的所有节点**都**比根节点大**。

**深度**
平均深度是O(log N)。

### 4.3.1 contains方法
使用递归调用来查找，因为平均栈深度为O(log N)。
**首先**得对节点进行**空树测试**，否则会产生一个NullPointerException异常。应该将**最不可能的情况**(概率最小的情况，即相等)安排到**最后测试**。
这里的递归表达式都是**尾递归**，可以用while循环代替。

也可以使用**函数对象**来实现比较。

### 4.3.2 findMin方法和findMax方法

两个private分别返回树中最小元和最大元的**节点引用**。
这里findMin采用递归实现，而findMax采用循环实现。

首先得处理**空树**的退化情况。

### 4.3.3 insert方法

类似于contains方法，对于**重复元**的处理方法有两种：
1. 不添加
2. 添加一个附加域来存储重复元的频率。

### 4.3.4 remove方法

最困难的操作是remove方法。
情况主要分为3种：
1. 删除的是**叶子节点**，这种情况可以直接删除。
2. 删除的节点只有一个子树，这种情况可以用子树的根直接替代当前节点。
3. 删除的节点有两个子树：
对于这种情况有多种策略可以采用：
1). 通过中序遍历的前继或者后继来替代当前元素，这种策略中采用**后继元**会比较好处理，即通过将右子树的最小节点替代当前删除节点，因为**右子树的最小节点不可能有左子树**，所以操作上会方便些。
2). 如果删除的次数不多，则使用**懒惰删除**，如果树中删除的节点和实际节点数一样，树的**深度**只会比真实删除的情况多一个**常数**。

### 4.3.5 平均情况分析

当我们每降低一层，我们操作树的大小就近似减少一半。所有的操作时间为O(d)，其中d为**访问节点的深度**。

**内部路径长**
一个树所有节点的深度的和称为**内部路径长**。

现证明假设所有插入序列都是等可能的，则树所有节点的平均深度为O(log N)。

证明：
> 令D(N)为具有N个节点的树T的内部路径长，D(1)=0。
>一棵N节点的树由一棵i节点的左子树和一棵(N - i - 1)节点的右子树组成，其中0<=i<N。
> D(i)是左子树的内部路径长。
> 原树种所有节点深度都加1,所以得到递推关系
> D(N)=D(i)+D(N - i - 1) + N - 1。
> 如果所有子树的大小都是等可能出现，对于**二叉查找树**是成立的，但对于**二叉树**不成立。(因为二叉查找树中子树的大小只依赖于第一个插到树种的元素想对的**秩**)。
> 那么D(i)和D(N - i - 1)平均值均为$\frac{1}{N} \sum_{j=0}^{N-1} D(j)$。
> 所以
> $D(N)=\frac{2}{N} \sum_{j=0}^{N-1} D(j) + N - 1$
> 最终求解得**D(N)=O(NlogN)**。所以**任意节点的平均深度为O(log N)**。

对于所有操作的平均运行时间为O(log N)，即d=log N。但是**删除操作**是否会导致所有二叉查找树是否**等可能出现**，所以**不能判断二叉查找树的所有操作是O(log N)**，但是对于**无删除操作或使用懒惰删除的二叉查找树，所有的操作是O(log N)**。

有人已经证明，如果**交替插入删除**$\Theta(N^2)$次，则树的平均深度为$\Theta(\sqrt N)$。

为了平衡插入删除操作后的树的深度，可以使用如下策略：
1. **随机选取**删除元素的**右子树**的最小和最大元来替代当前元素。
2. 使用**平衡结构**，让树的深度不能过深。
3. 使用称为**自调整类结构**。

在二叉查找树情况下，不保证**单个操作**时间为O(log N)界，但是对于**连续M次操作**在最坏情形下花费时间为O(MlogN)。
能达到这种效果的树称为**伸展树**。

## 4.4 AVL 树

定义：
AVL树是**带平衡条件**的**二叉查找树**。

对于平衡条件必须是容易保持的，这保证了树的深度为O(log N)。
一颗AVL树是其中每个节点的左子树和右子树的高度最多相差1的二叉查找树(**空树**的高度定义为-1)。

可以证明，粗略地说，AVL的高度**最多**为**1.44 log(N+2) - 1.328**

在AVL树中**最少节点数S(h)**，其中h为树的高度
> S(h)=S(h-1)+S(h-2)+1得出，S(0)=1;S(1)=2。这个数和斐波那契数列密切相关，这个可以定义为AVL树的下界
> AVL树的**上界**是普通树的上界$L(h)=2^k-1$

可以由节点数的界推出高度的界：$log(N+1) \leq h \leq 1.44log(N+2) - 1.328$
节点数T(h)的界：$ S(h) \leq T(h) \leq 2^k -1,S(h)=S(h-1)+S(h-2)+1,S(0)=1,S(1)=2$

对于AVL树，**插入**一个节点可能会破坏AVL树的平衡条件，为此在插入后需要进行**旋转**操作来重新使树平衡。

寻找平衡条件被破坏的节点：
> 只有**插入节点到根节点路径**上的节点平衡条件会改变，其他节点的平衡条件不会改变。

由于平衡条件为左右子树的高度差小于等于1，所以破坏平衡条件的左右子树高度差至少为2。

设不平衡的第一个节点为$\alpha$
不平衡的情况有四种：
1. 对$\alpha$的左儿子的左子树插入。
2. 对$\alpha$的左儿子的右子树插入。
3. 对$\alpha$的右儿子的左子树插入。
4. 对$\alpha$的右儿子的右子树插入。

其中1和4为镜像，2和3为镜像。所以实际上只有两种情况。

使用**单旋转**来解决LL和RR的情况，使用**双旋转**来解决LR和RL的情况。

### 4.4.1 单旋转

**LL型**
 平衡二叉树某一节点的左孩子的左子树上插入一个新的节点，使得该节点不再平衡。
 这时只需要把树向右旋转一次即可，如图所示，原A的左孩子B变为父结点，A变为其右孩子，而原B的右子树变为A的左子树，注意旋转之后Brh是A的左子树（图上忘在A于Brh之间标实线）
 <br>
 ![LL](/AVL树平衡操作/LL.jpg)

 **RR型**
 平衡二叉树某一节点的右孩子的右子树上插入一个新的节点，使得该节点不再平衡。这时只需要把树向左旋转一次即可，如图所示，原A右孩子B变为父结点，A变为其左孩子，而原B的左子树Blh将变为A的右子树。
 ![RR](/AVL树平衡操作/RR.jpg)

**LR型**
平衡二叉树某一节点的左孩子的右子树上插入一个新的节点，使得该节点不再平衡。这时需要旋转两次，仅一次的旋转是不能够使二叉树再次平衡。如图所示，在B节点按照RR型向左旋转一次之后，二叉树在A节点仍然不能保持平衡，这时还需要再向右旋转一次。
![LR](/AVL树平衡操作/LR.jpg)

**RL型**
平衡二叉树某一节点的右孩子的左子树上插入一个新的节点，使得该节点不再平衡。同样，这时需要旋转两次，旋转方向刚好同LR型相反。
![RL](/AVL树平衡操作/RL.jpg)

> 可以发现上述旋转操作会使树的高度减1

## 4.5 伸展树

**伸展树**保证从**空树**开始连续M次对树的操作**最多**花费O(Mlog N)时间。

但是不排除**单次操作**花费O(N)的时间，虽然**每次操作**时间界没有O(log N)那么强，但是实际效果是一样的：不存在坏的输入序列。

> 当M次操作的**最坏情形**运行时间为O(Mf(N))时，则称**摊还**运行时间为O(f(N))。

如果任意操作最坏时间界为O(N)，而我们仍然要求一个O(logN)的摊还时间界，则只要一个节点被访问，则该节点就被移动。
如果不移动的话，则M次操作后花费时间为O(MN)。

当一个节点被访问后，该节点就会经过一系列的AVL树的旋转推到根上。如果节点很**深**，则到其的路路径上就有较深的节点，这些节点也需要被重新构造，达到某种平衡。

### 4.5.1 一个简单的想法(不能直接)

重新构造的方法是执行**单旋转**，从底向上进行。
但是这种操作可能会造成路径上的其他节点向深处推进，导致M次操作最终时间仍为O(MN)。

例如向空树插入$1,2,\cdots,N$所形成的树，该树只有左儿子组成，建立时间为O(N)。但是访问i的时间为O(N-i)，如果访问的序列为建立的序列，则访问关键字的时间为$O(N^2)$。在访问后，重构的树就会变成初始的状态，可能会重复访问这个序列。

### 4.5.2 展开

与AVL树的情况类似，访问的节点有四种情况：LL,RR,LR,RL。同样使用AVL树的旋转操作，最终将访问节点推向根节点。

可以看到，展开操作会让访问路径上的大部分节点深度减少一半(某些浅的节点最多向下推后两层)。

当访问耗时很少时，这些旋转操作可能不是有益甚至是有害的。

例如，所有插入操作都是导致坏的初始树的花费常数时间的操作。虽然会得到一颗很差的树，但是运行却比预计快，从而总的较少运行时间**补偿**了损失。

可以通过访问**要被删除节点**来实现删除操作，这种操作会将节点推到根上，删除根会得到两颗子树，$T_L$和$T_R$。可以找到$T_L$最大的元素，通过旋转到$T_L$的左子树下，此时$T_L$将会有一个没有右儿子的根，可以让$T_R$转为该根的右儿子从而完成删除。

## 4.6 树的遍历

**中序遍历**

应用：运算表达式

**后序遍历**

应用：文件目录大小计算

**先序遍历**

应用：目录打印

**层序遍历**

使用**队列**，而不是**栈**。

## 4.7 B 树($B^+树$)

可以看出：当树的分支更多，树的深度越浅。

一颗完全M叉树的高度为$O(\log_M N)$。

为了让操作时间短，需要让M叉树**平衡**。否则可能，M叉树也会退化成链表。

阶为M的B树具有以下特性：

> 1. 数据项存储在树叶上
> 2. 扉页节点
