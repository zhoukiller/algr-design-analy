# 第五章 散列

散列表的实现叫**散列**。散列适用于以常数平均时间插入删除和查找的技术。但是关于排序信息操作不会得到支持。

## 5.1 一般想法

通常查找是对项的某个部分进行，这部分称为**关键字**。

项可以有一个串(可以作为关键字)和其他一些数据项组成。我们把表的大小设置为TableSize，表从0到TableSize - 1变化。

每个关键字被映射到0到TableSize-1的表中的某个位置。这个映射称为**散列函数**。
由于表的元素有限，所以需要解决当两个关键字映射到同一个位置的情况，这种情况称为**冲突**。

## 5.2 散列函数

好的办法通常是保证表的大小为素数。当关键字是随机输入时，散列函数不仅计算起来简单而且关键字的分配也很均匀。
通常，关键之是**字符串**。

散列函数方法：

1. 将字符串中的字符ASCII码(或Unicode码)值加起来。当表很大时，函数不会很好分配关键字。例如，关键字8个字符长，8*127=1016,显然会造成分配不均匀。

2. 利用字母加空格共27个字符，只考虑前三个字符，则27^3为最大空间位置。但是由于英文不是随机分布的，所以会有很多空间被浪费。

3. $\sum_{i=0}^{KeySize -1} Key[KeySize - i - 1]*37^i$，并将结果限制在一定范围，该函数散列分布会很好。该函数利用Horner法则计算$h_k=k_0+37k_1+37^2k_2$。该函数运行溢出。可能引进负的数，在末尾有附加的测试。

有时候不需要计算所有的字符串，当关键字过长时，散列函数计算会花费过多时间，可以选择计算前n项字符。

接下来需要解决当一个元素插入时与一个已经插入元素散列到同一个值得情况，需要将该冲突解决。这里讨论两个最简单的冲突解决方法：分离链接法和开放定址法。

## 5.3 分离链接法

该方法将散列到同一值得所有元素保存到一个表中。可以使用标准库的实现方法(双向链表)，如果空间很小，则避免使用双向链表。

为执行一次查找，使用散列函数来确定遍历链表的位置，然后再在链表中执行一次查找。为执行insert，我们需要检查相应的链表该元素是否已经处在适当的位置(如果允许重复插入，通常还有留出一个用于统计频率的域)。如果该元素是新元素，则插入到链表的前端，因为：新插入的元素往往会在不久的将来被访问。

```
public class SeparateChainingHashTable<AnyType>
{
  public SeparateChainingHashTable()

  public SeparateChainingHashTable(int size)

  public void insert()

  public void remove(AnyType x)

  public boolean contains(AnyType x)

  public void makeEmpty()

  private static final int DEFAULT_TABLE_SIZE=101;

  private List<AnyType> [] theLists;
  private int currentSize;

  private void rehash()

  private int myhash(AnyType x)

  private static int nextPrime(int n)

  private static boolean isPrime(int n)

}
```

在Java中这样的对象必须提供适当的equals方法和返回一个int型量的hashCode方法。

在插入例程中，当元素已经存在时，不做任何操作；否则将其放入链表中。链表可以被一个二叉查找树或者另一个散列表替代。

定义散列表的**装填因子**$\lambda$为散列表中的元素个数对该表的大小的比。

遍历散列表的时间是计算散列函数值的常数时间加上遍历链表所用的时间。

被搜索的链表包含匹配的节点在加上0或更多的其他节点。

在N个元素的散列表以及M个链表中的**其他节点**的期望个数为$(N-1)/M=\lambda - 1/M$，该值基本上为$\lambda$，因为假设M是大的。

平均来看，一半的**其他节点**被搜索到，在结合匹配节点，得到$1+\lambda/2$个节点的平均查找代价。

这个分析指出，散列表的大小不重要，**装填因子才重要**。

分离链表散列法的一半法则是让$\lambda\approx1$。如果超过了1，则通过rehash方法扩大散列表的大小。

##5.4 不用链表的散列表

由于分配新单元需要时间，所以算法的速度有所减慢，同事该算法还要求对第二种数据结构的实现。

另一种不用链表解决冲突的方法是，当冲突发生时按照一定规则，直到找到空的单元为止。单元$h_0(x),h_1(x),h_2(x),\cdots$背相继选中,$h_i(x)=(hash(x)+f(i)) mod TableSize$,且f(0)=0。函数f是解除冲突的方法。

对于不使用分离链接的散列表来说，装填因子应该低于0.5。这样的表叫做**探测散列表**。

### 5.4.1 线性探测法

函数f为i的线性函数，典型情形为f(i)=i。

当表较空，占据的单元会形成一些区块，其结果成为**一次聚集**。

可以证明，使用线性探测的预期探测次数对于插入和不成功的查找来说大约为$\frac{1}{2}(1+1/(1-\lambda)^2)$，对于成功的查找来说是$\frac{1}{2}(1+1/(1-\lambda))$
