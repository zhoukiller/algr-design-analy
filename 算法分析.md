# 第二章 算法分析

## 2.1 数学基础

本书将会使用以下4个定义：

**定义2.1** 如果存在正常数c和$n_0$使得当$N\geq n_0$时$T(N)\leq cf(N)$,则记为$T(N)=O(f(N))$。

**定义2.2** 如果存在正常数c和$n_0$使得当$N\geq n_0$时$T(N)\geq cg(N)$,则记为$T(N)=\Omega (g(N))$。

**定义2.3** $T(N)=\Theta (h(N))$当且仅当$T(N)=O(h(N))$和$T(N)=\Omega(h(N))$。

**定义2.4** 如果对每一正常数c都存在常数$n_0$使得当$N>n_0$时$T(N)<cp(N)$，则$T(N)=o(p(N))$。有时也可以说，如果$T(N)=O(p(N))$且$T(N)\neq \Theta(p(N))$，则$T(N)=o(p(N))$。

一般来说T(N)=O(f(N))，则说f(N)是T(N)的**上界**；$T(N)=\Omega(f(N))$，则说f(N)是T(N)的**下界**。

**计算法则**

**法则1**

如果$T_1(N)=O(f(N))$且$T_2(N)=O(g(N))$，那么
(a) $T_1(N)+T_2(N)=O(f(N)+g(N))$，或非正式max(O(f(N)),O(g(N)))。
(b) $T_1(N)* T_2(N)=O(f(N) * g(N))$

**法则2**

如果T(N)是一个k次多项式，则$T(N)=\Theta (N^k)$。

**法则3**

对任意常数k，$log^k N=O(N)$。所以对数增长很缓慢.

## 2.2 模型

为了分析算法的性能，建立了一个理想的计算机模型。

## 2.3 要分析的问题

**运行时间**

**输入大小** 定义两个函数$T_avg(N)$和$T_worst(N)$。显然$T_{avg}(N) \leq T_{worst} (N)$。

### 最大子序列和问题

[参考文献1](http://blog.csdn.net/hcbbt/article/details/10454947)
[参考文献2](http://blog.csdn.net/zhaobryant/article/details/38537457)

## 2.4 运行时间计算

### 2.4.2 一般法则

**法则1 ————for循环**

一个for循环的运行时间至多是该for循环内部**语句运行时间**乘以**迭代次数**。

**法则2 ————嵌套的for循环**

循环的运行时间为**循环内部语句运行时间**乘以**所有for循环**的大小的乘积。

**法则3 ————顺序语句**

将各条语句**求和**即可。

**法则4 ————if/else语句**

```Java
if(condition)
  S1
else
  S2
```

一个if/else语句的运行时间为从不超过判断的运行时间在**加**上**S1和S2**运行时间**长者**的总运行时间。

> 分析的基本策略:**从内向外展开**；如果有**方法调用**，**首先分析调用**；如果有**递归**，存在几种选择，比如该递归实际上是一个for循环。

### 2.4.3 最大子序列和问题求解

[几个算法](http://blog.csdn.net/zhaobryant/article/details/38537457)

### 2.4.4 运行时间的对数

> 对数运行时间的规律：如果一个算法将其大小划分为其**一部分(1/K)**,则算法是O(logN)的，如果只是减少了一个常数量，则算法为O(N)的。

**折半查找**

**欧几里得算法**

**定理2.1** 如果M > N，则M mod N < M/2

所以迭代次数**至多**为2logN=O(logN)。

**幂运算**

计算$X^N$是使用N-1乘法自乘。如果使用递归算法，如果N为偶数，$X^N=X^{N/2}*X^{N/2}$；如果N为奇数，$X^N=X^{N/2}*X^{N/2}*X$
